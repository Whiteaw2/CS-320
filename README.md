# CS-320
###CS-320 Software Test Automation &amp; QA

The following files and description showcase my work in software testing, automation, and quality assurance leveraging unit tests in Java, analyzing the performance of the codebase and meeting user requirements during development.
 
## How can I ensure that my code, program, or software is functional and secure?
During the software development lifecycle, it is critical that the codebase is created with thorough requirements and use case understanding and that various test methods are employed (both manual and automated) during the iterative development process. By ensuring that the conversations and requirements gathering phases are conducted thoroughly, that the various stages of static testing are complete with the perspective of stakeholders and other teammates, we approach a sustainable pipeline with which to start developing functional and secure code. By doing frequent reviews and accounting for edge cases, leveraging unit tests, and manual reviews of our codebase, we can ensure that we're developing the right functionality in a robust way at each stage. It is important to make sure that the early testing procedures are done thoroughly as we will enable flexibility at a much lower final cost to the company and end users. Throughout the process though, it is our responsibility as developers to ensure high quality including during the variants of integration testing, regression testing, and user acceptance testing. It is equally important to continue leveraging the available tools to refine, maintain, and retroactively test for vulnerabilities in our solution over time.

## How do I interpret user needs and incorporate them into a program?
To effectively interpret user needs and incorporate them into our solution, it is best to open direct lines of communication with users, conduct high level conversations about expected functionality, critical areas of need or friction, and nice-to-haves. Users won't know what the solution looks like, but they will likely know what features or touch points are required to deliver a relevant product, and more importantly what problems they currently face. It should be noted that often the solution may need to be interpreted indirectly from the user, as they may focus too much on similar existing solutions, may have a limited view of requirements, or may not understand some level of constraints. From these user interviews we distill the descriptions into a set of functional requirements which we use to generate prototypes and architectures which will enable the solution to the users' problems. After we test these prototypes with users, we further collect feedback and refine our requirements for development. From here we continue to iteratively design, implement, and test our solution while maintaining relevance to users in meaningful increments. Again, it is important that we test for soundness of code with security as well as edge cases which may account for significant, but less likely scenarios during use. 

## How do I approach designing software?
As described above, I do my best to ensure that software addresses the core needs of the users, leverages the expertise of our broader development team, ensures security and robustness (failing gracefully), and is most performant. As solution designers is critical to deliver relevant systems to users, simultaneously offering security and compliance with consistent performance.

